# -*- coding: utf-8 -*-
"""integration_newton_cotes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18TKNZV_EIbbcqSDcrQhOwATl8v1T-8OS
"""

#IMPORTA BIBLIOTECAS
import numpy as np
import scipy as sy
from numpy.polynomial import Polynomial

#CALCULA INTEGRAL SEGUNDO REGRA DA COMPOSIÇÃO DE INTEGRAL
#REF: STOCHASTIC SIMULATION ALGORITHMS AND ANALYSIS

def compose_int(f,a,b,n,k):

  #INICIA SOMA TOTAL
  soma_total = 0

  #PARTIÇÃO MAIOR 
  particao_1 = [a + i*(b-a)/n for i in range(n+1)]

  #PERCORRE PARTIÇÃO MAIOR
  for i in range(1,len(particao_1)):
    
    #SOMA PARA CADA SUBINTERVALO DA PARTIÇÃO MAIOR
    soma_particao = 0

    #SUBPARTIÇÃO 
    particao_2 = [particao_1[i-1] + j*(particao_1[i]-particao_1[i-1])/k for j in range(k+1)]

    #PERCORRE A SUBPARTIÇÃO
    for k in range(1,len(particao_2)):
      
      #ACRESCENTA SOMA PARTIÇÃO
      soma_particao += f((particao_2[k] + particao_2[k-1])/2)*(particao_2[k]-particao_2[k-1])
    
    #ACRESCENTA A SOMA DA PARTIÇÃO NA SOMA TOTAL
    soma_total += soma_particao

  #RETORNA SOMA_TOTAL
  return soma_total

#FUNCAO QUE DEVOLVE LISTA DOS L_I DA INTERPOLAÇÃO
def interpolacao(lista_x):

  #LISTA DOS L
  lista_l = []

  #PERCORRE OS X
  for i in range(len(lista_x)):

    #ARMAZENARA O L (NUMERADOR E DENOMINADOR)
    expressao_numerador = 1
    expressao_denominador = 1

    #PERCORRE OS X EXCETO O DO PONTO E ATUALIZA A EXPRESSAO
    for j in range(len(lista_x)):

      if lista_x[j] != lista_x[i]:

        #INCREMENTA AS EXPRESSÕES DO NUMERADOR E DENOMINADOR
        expressao_numerador *= Polynomial([-lista_x[j],1])
        expressao_denominador *= (lista_x[i]-lista_x[j])
    
    #APPENDA NA LISTA
    lista_l.append([expressao_numerador,expressao_denominador])

  #RETORNA A LISTA
  return lista_l


#TRANFORMA POLINOMIOS DADOS EM FUNÇÃO QUE RETORNA SUA DIVISÃO 
def transf(lista_pol):

  #DEFINE A FUNÇÃO L_i
  def funcao(x):

    #COEFICIENTES NUMERADOR
    coeficientes_numerador = lista_pol[0].convert().coef
    #COEFICIENTE DENOMINADOR
    coeficiente_denominador = lista_pol[1]

    #SOMA DO NUMERADOR
    soma_numerador = 0

    #PERCORRE COEFICIENTES NUMERADOR E INCREMENTA SOMA
    for i in range(len(coeficientes_numerador)-1,-1,-1):
      soma_numerador += (coeficientes_numerador[i]*(x**(i)))
    
    #RETORNA DIVISÃO
    return soma_numerador/coeficiente_denominador

  #RETORNA A FUNÇÃO CRIADA
  return funcao

#FUNÇÃO DE INTEGRAL NEWTON COTES
def int_newton_cotes(f,a,b,n):

  #PARTIÇÃO DO DOMINIO
  particao = [a + i*(b-a)/n for i in range(n+1)]

  #INICIA O PRODUTO
  produto = 0
  
  #PERCORRE PARTIÇÃO
  for i in range(len(particao)):
    

    #FUNÇÃO L_i
    l_i = transf(interpolacao(particao)[i])

    #ITERA PRODUTO COM f(x_i)*integral(L_i)
    produto += f(particao[i])*compose_int(l_i,a,b,100,100)

  return produto

#EXEMPLO DE F
def f(x):
  return x*(x+1)**(1/3)

#RESULTADO WOLFRAM: 0.59141
print(int_newton_cotes(f,0,1,4))

