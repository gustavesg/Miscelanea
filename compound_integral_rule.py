# -*- coding: utf-8 -*-
"""Compound_Integral_Rule.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/163Aj6wG7Yvq9YyR3Ov7nVBGOKA-myWVG
"""

#IMPORTA BIBLIOTECAS
import numpy as np
import math
import matplotlib.pyplot as plt

#CALCULA INTEGRAL SEGUNDO REGRA DA COMPOSIÇÃO DE INTEGRAL
#REF: STOCHASTIC SIMULATION ALGORITHMS AND ANALYSIS

def compose_int(f,a,b,n,k):

  #INICIA SOMA TOTAL
  soma_total = 0

  #PARTIÇÃO MAIOR 
  particao_1 = [a + i*(b-a)/n for i in range(n+1)]

  #PERCORRE PARTIÇÃO MAIOR
  for i in range(1,len(particao_1)):
    
    #SOMA PARA CADA SUBINTERVALO DA PARTIÇÃO MAIOR
    soma_particao = 0

    #SUBPARTIÇÃO 
    particao_2 = [particao_1[i-1] + j*(particao_1[i]-particao_1[i-1])/k for j in range(k+1)]

    #PERCORRE A SUBPARTIÇÃO
    for k in range(1,len(particao_2)):
      
      #ACRESCENTA SOMA PARTIÇÃO
      soma_particao += f((particao_2[k] + particao_2[k-1])/2)*(particao_2[k]-particao_2[k-1])
    
    #ACRESCENTA A SOMA DA PARTIÇÃO NA SOMA TOTAL
    soma_total += soma_particao

  #RETORNA SOMA_TOTAL
  return soma_total

#FUNÇÃO F DE TESTE 
def f(x):
  return math.sqrt(1 + x**10)

#INTEGRAL 0 A 1 WOLFRAM: 1.0409
compose_int(f,0,1,1000,1000)

#CONVERGE MUITO RÁPIDO
resultados = []
for i in range(1,100):
  resultados.append(compose_int(f,0,1,i,i))

plt.plot([i for i in range(1,100)],resultados)

